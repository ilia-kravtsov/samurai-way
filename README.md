С помощью create react app type script создаем новое приложение

Удаляем лишнее из компоненты App 

добавляем в основной возвращаемый div глобальные структурные разделы проекта
header nav body footer и т.д.

С помощью css выравниваем по центру и задаем максимальную ширину для всего контента 
А так же разбиваем контент на отдельные зоны с помощью grid

Далее разбиваем каждую отдельную зону на отдельные блоки div с кратким описанием 

Распределяем весь код по отдельным компонентам для каждой отдельный файл, группируем в отдельной папке
single responsibility

для каждой компоненты с форматом tsx создаем отдельный css файл и группируем их в отдельную папку 
импортируем css файлы в файлы tsx к которым они относятся

Стили классов одной компоненты css применяются и для другой компоненты и без import export 
если в tsx файле употребить название класса заданного в css другой компоненты

Все tsx файлы превращаются в один tsx файл который называется bundle.js
по network никаких css файлов при запуске проекта к нам не приходит к нам приходит только js код
и этот js код добавляет css в html элемент прям в тело документа в head в тег style перед body
Все css файлы по итогу попадают в один глобальный header в один глобальный набор стилей

То есть по факту так как стили для любой разбитой структурно компоненты все равно оказываются в одном и том же месте
именно поэтому любой стиль из такого css блока для конкретной компоненты влияет на все остальные компоненты

То есть если где-то в css файле для конкретной компоненты мы пропишем название класса item то в любой другой компоненте 
где мы укажем item применятся стили из первой компоненты.

А если мы хотим чтобы стили из конкретной компоненты влияли только на нее то мы 
переименовываем css файл в модуль Nav.css в Nav.module.css
модуль он же css объект и теперь при импорте import './Nav.css' нужно писать
import "задаем название стилей" from './Nav.module.css'

После задания слова module в названии в браузер будет приходить не класс nav из css (который мы задавали 
в css файле), а Nav_item__wbQ2R, что позволяет нам в css файле писать короткие названия и не думать о том
как сделать название уникальным и при этом они будут дейтсвовать только на ту компоненту на которую нам нужно.

Для того чтобы пользоваться этой технологией нужно использовать название стилей которое мы задали при импорте модуля
import "задаем название стилей" from './Nav.module.css'
например import NavStyle from './Nav.module.css'

NavStyle - объект. Объект это структура данных у которой есть ключ-значение 
let NavStyle {
    '' : '',
    '' : '';
} -> объект

т.о. NavStyle - тоже объект ключами которого являются названия стилей которые мы написали в css файле только без точки
класс nav класс item

let NavStyle {
'nav' : '',
'item' : '';
} 

а значениями этих ключей будут те самые Nav_item__wbQ2R уникальные значения которые задаются при указании нами
слова module в названии css файлов

let NavStyle {
'nav' : 'Nav_item__wbQ2R',
'item' : 'Nav_item__wbQ2R';
} 

т.о. чтобы применить свойства и значения указанные в css модуле в tsx файле нам нужно
в className указать = {} - значит что мы внутрь jsx разметки хотим вставить js код
className={NavStyle.nav}

При этом для картинок которые вложены в теги при проведении действий выше для родительского тега
ничего делать не потребуется стили которые были указаны как вложенные применятся и к ней header img

в js запрещено в названии свойства объекта указывать - 
если в имени мы используем - то тогда мы должны обращаться к такому свойству с помощью ['header-img']
- не используем _ используем

Если мы хотим указать 2 стиля для элемента

по старинке в jsx файле мы бы написали className='item active'
а в css .item.active {...}

let c1 = 'item'
let c2 = 'active'
let cssModuleObject = c1 + ' ' + c2;

but in ecma script 6 

let cssModuleObject = `${c1} ${c2}` the same with - let cssModuleObject = c1 + ' ' + c2; ;
если мы внедряем в jsx js код то мы пишем его в {}
если мы внедряем js в строку то мы пишем его в `${}`

now

mainCssModuleObject = `${CssModuleObject.item} ${CssModuleObject.active}`
но так как `` - это тоже js инструкция то вс. эту х..ню мы тоже оборачиваем в {} и получаем
mainCssModuleObject = {`${CssModuleObject.item} ${CssModuleObject.active}`}

то есть бл... вот так - <div className={`${NavStyle.item} ${NavStyle.active}`}>

чтобы узнать приходят ли свойства в объект просто выводим его в console.log()

Группируем css и tsx файлы компонент в отдельные папки

Дробим на компоненты всё что дробится, а дробится всё.

Propsы Propsы Propsы...

Когда мы пишем в tsx разметке 

<Post /> - это значит что в компоненте Props создаётся пока пустой объект {} 
с входными данными компоненты - которых пока нет. 
Этот пустой объект называется props (похоже на сокращение от properties) хотя его можно было назвать хоть crops
но propsами его договорились называть программисты.

Как этим пользоваться

<Post value="007"/> Когда мы добавляем в компоненту атрибут value="007" в наш объект props попадает

{
value: 007;
}

props={value:007} и теперь внутри самой компоненты, мы можем обращаться к объекту props

{props.value} подставит нам вместо написанного 007

собсна всё.

Если мы напишем 

<Post value="007" name="ilai"/>

то в объекте props у нас будет 

{
    value: 007,
    name: 'ilai'
}

ствесна далее мы можем обращаться как {props.value} так и {props.name} первое выдаст 007 второе 'ilai'

Идея в чём, в том что таким образом можно решить основную проблему "дублирование кода"

мы сможем брать один и тот же <Post/> и добавляя в него разные атрибуты
(то есть добавляя разные свойства и значения в объект props компоненты Post)
влиять на то как конкретный пост будет отображаться в браузере,
то есть влияя на вход получаем разный выход.
То есть наша функция будет иметь доступ к объекту props

Ещё важный момент что если мы напишем 

<Post value="007"/>
<Post name="ilai"/>

это значит что react вызовет функцию Post - 2 раза (компонента эта функция которая возврщает разметку jsx)
но в первом случае она вызовется со значением которое мы указали в первый раз 
во втором случае она вызовется со значение которое мы указали во второй раз

React_17

1 компонента 1 папка 

React_18

Компонента это функция которая возвращает разметку jsx, именуется с большой буквы и принимает на входе объект props
props нужен компоненте для того чтобы на выходе при вызове одной и той же функции получать разную разметку.

Функция должна работать очень предсказуемо
Функция должна возвращать что-либо основываясь только на входящих данных

Предсказуемость поведения заключается в том что если всегда приходит одинаковый объект props
значит функция всегда вернет одинаковую разметку, но если объект props разный на входе, то и на выходе
разметка будет разной

React_19 

Делаем ссылки кликабельными, работа с роутингами (маршрутизация)

Нам нужна система роутинга которая будет отслеживать адрес указаннный в адресной строке

В комопненте App в <div className='app_wrapper_content'> должна появляться та компонента которая будет
соответствовать url указанному в адресной строке, который будет изменяться в зависимости от нажатия по ссылкам 
указанным в nav

Вся логика spa изначально отрабатывает вне зависимости от url но нам нужно установить такой пакет программу модуль
с помощью которой после нажатия по ссылкам nav spa отрабатывал бы в зависимости от url
для этого нужно настроить систему маршрутов

разработчики cra не включили в node js пакет программу модуль которая работает с модулями поэтому нам нужно установить 
дополнительно

для этого в терминале прописываем

npm i react-router-dom

после этой команды необходимый пакет установится в node_modules но когда код отправится в gid репозиторий
этот пакет туда уже не пойдет потому что папка node_modules находится в git.ignore
соответственно у других людей так работать не будет

поэтому к команде npm i react-router-dom мы должны добавить -save
npm i react-router-dom -save
это значит что пакет необходимо не просто установить а еще и внести запись в package.json файл
package.json файл это главный файл который характеризует нашу папку как проект

в package.json файле записаны все зависимости
когда мы активируем команду с -save  ->  npm i react-router-dom -save
в package.json появится запись
и в node-modules пакет установится и мы закинем изменения на сервер
и попрежнему у коллег этого пакета не будет но
у них будет запись в package.json и для того чтобы у них пакет восстановился
им нужно будет просто написать npm i то есть доустановить недостающие пакеты

npm i - npm анализирует зависимости прописанные в файле package.json и в папке node_modules
сравнивает смотри чего не хватает и доустанавливает отсутствующие зависимости

При кликах на ссылки у нас меняется путь в браузерной строке и наша задача анализировать путь
и подставлять нужную компоненту вместо этого пути

Для этого есть специальная компонента <Route/> 

import {Route} from 'react-router-dom' {} - потому что Route экспортируется не по дефолту

добавляем атрибут component чтобы каждый Route отвечал за свою компоненту

<Route component={название компоненты без кавычек и других скобок}/> 

<Route component={Dialogs} /> - ты отрисуешь Dialogs когда нужно
<Route component={Profile} /> - а ты отрисуешь Profile когда нужно

а когда нужно? зависит от url который меняется так как мы указали <a href='/profile'>profile</a>

Если мы где-либо используем <Route/> значит необходимо обернуть эти теги в корневой элемент
<BrowserRouter> </BrowserRouter>  мы обернули в него все App сразу внутри return () первым тегом

Для того чтобы каждая компонента <Route/> понимала к какой ссылке относится нужно задать атрибут path
где указываем окончание url по которому <Route/> поймет когда запускаться например
<Route path='/dialogs' component={Dialogs}/>

То есть <Route/> анализирует ссылку в адресной строке и если окончание ссылки совпадает с path то отрисовывает
компоненту указанную в component, а первоночально окончание url задаем в блоке со ссылками либо атрибутами href
либо to

Наша задача изменить адресную строку браузера не перезагружая страничку для этого используется спец тег 
<NavLink></NavLink>
NavLink импортируется
import {NavLink} from 'react-router-dom';

вместо <a href=''></a> используется атрибут to
<NavLink to='/profile'></NavLink>

NavLink - это компонента у этой компоненты есть свой атрибут to все эти атрибуты по итогу превращаются в props
NavLink - возвращает тот же самый тег а поэтому если в стилях задать что-либо для a то это применится и к NavLink

На а можно повесить addEventListener - обработчик события, подменить путь в адресной строке на нужный нам
history api позволяет делать изменения в адресной строке
а дальше он делает PreventDefault то есть отменяет действие по умолчанию
у а ссылки действие по умолчанию - отправить на тот путь который отрисован в атрибуте href

NavLink - возвращает ссылку, но я хочу отслеживать клик по тебе и когда по тебе будут кликать я буду
просто менять адрес в адресной строке браузера но не буду делать редирект перенаправление на эту страничку
я там сделаю PreventDefault

NavLink - так же добавляет класс active к классическому тегу a, но в реакте все равно нужно будет указывать
подобное через свойство объекта

Как сказать NavLink чтобы он добавлял активным ссылкам не класс active а тот который мы указали в css
и для этого у NavLink есть атрибут activeClassName

<NavLink to='/messages' activeClassName={navbarStyle.activeLink}>Messages</NavLink>
то есть теперь NavLink по умолчанию будет добавлять тот класс который мы указали в css 
и та ссылка на которой мы находимся станет золотого цвета

React 21 

Создаем css для messages

создаем 2 колонки в одной имена в другой сообщения 
в messages 2 колонки - значит 2 div
каждое имя - отдельная div

Задаем классы для всех div 
глобальная div className='messages'
ее потомок div className='messagesItems'
и конкретное имя div className='item'

Вторая колонка/div
div className='messages'

Переключение между вкладками webstorm ctrl alt -> <-

меняем классы в виде строк на модули

 <div className={messagesStyle.messages}></div>
 <div className={messagesStyle.messagesItems}></div>

 <div className={messagesStyle.messages}></div>
в css для обертки messages говорим что она является gridом

messages {
    display: grid;
}

и если в app варианте мы использовали подход grid-template-areas 
Здесь мы скажем что наш grid состоит из 2-х колонок
1 колонка занимает 2 фракции 
2 колонка занимает 10 фракций

grid-template-columns: 2fr 10fr;

Добавляем к одному из диалогов класс active через конкатенацию

<div className={messagesStyle.dialog + ' ' + messagesStyle.active}></div>

React 22

Переключаемся между собеседниками во вкладке messages

К каждому диалогу привязываем свой id который будет прописываться в том числе в адресной строке 
что даст нам в будущем возможность делиться ссылкой где будет сразу открываться нужный диалог

Поэтому каждое имя собеседника в списке messages прописываем через Navlink

Задача NavLink - поменять url в браузере без перезагрузки страницы на тот который указан в атрибуте to
<NavLink to='/messages/1'>ilai</Navlink>

Route следит за своим куском адресной строки и отображает даже если после нужного куска написано что угодно
чтобы этого не было применяется атрибут exact перед path

<Route exact path='/video' component={Video}/> то есть Route совершенно точно должен совпасть с path
и в этом случае при переходе по ссылке отображаться контент будет только тогда
когда в адресной строке 100% совпадение во всех остальных случаях нет

Необязательно при смене URL делать новый Route или подружаться новая компонента

Мы должны при смене URL показывать разные сообщения для каждого собеседника свои 
не другие компоненты а другие сообщения поэтому в данном случае Route не понадобится

